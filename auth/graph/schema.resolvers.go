package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"

	"github.com/tabed23/cloudmarket-auth/graph/jwt"
	"github.com/tabed23/cloudmarket-auth/graph/middleware"
	"github.com/tabed23/cloudmarket-auth/graph/model"
	"github.com/tabed23/cloudmarket-auth/graph/utils"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	// Fetch user by email
	user, err := r.UserByEmail(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user by email: %w", err)
	}

	// Validate password
	if !utils.CheckPasswordHash(password, user.Password) {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Generate JWT token
	token, err := jwt.GenreateJwt(ctx, user.ID, user.Email, user.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate JWT: %w", err)
	}

	// Generate refresh token (same for simplicity in this case)
	refreshToken := token

	// Convert user to GraphQL user model
	usr := model.ConvertToGraphQLUser(*user)

	// Return AuthPayload with token and refreshToken
	return &model.AuthPayload{
		Token:        token,
		RefreshToken: refreshToken,
		User:         usr,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.NewUser) (*model.AuthPayload, error) {
	hashpass, err := utils.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	user := model.NewUserModel{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
		Password:  hashpass,
		Role:      "USER",
	}

	if r == nil {
		return nil, fmt.Errorf("user service is nil")
	}

	createUser, err := r.UserCreation(ctx, &user)
	if err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// Check if createUser is nil
	if createUser == nil {
		return nil, fmt.Errorf("created user is nil")
	}

	token, err := jwt.GenreateJwt(ctx, createUser.ID, createUser.Email, createUser.Role)
	if err != nil {
		return nil, fmt.Errorf("failed to generate JWT: %w", err)
	}

	refreshToken := token
	usr := model.ConvertToGraphQLUser(*createUser)

	return &model.AuthPayload{
		Token:        token,
		RefreshToken: refreshToken,
		User:         usr,
	}, nil // Fixed: was returning err instead of nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, email string) (string, error) {
	usrer, err := r.UserByEmail(ctx, email)
	if err != nil {
		return "", fmt.Errorf("failed to fetch user by email: %w", err)
	}
	err = r.UserDelete(ctx, usrer.Email)
	if err != nil {
		return "", fmt.Errorf("failed to delete user: %w", err)
	}
	return fmt.Sprintf("user with email %s deleted successfully", email), nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, email string, input *model.NewUser) (string, error) {
	user, err := r.UserByEmail(ctx, email)
	if err != nil {
		return "", fmt.Errorf("failed to fetch user by email: %w", err)
	}
	hashpass, err := utils.HashPassword(input.Password)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}
	usr := model.NewUserModel{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
		Password:  hashpass,
		Role:      user.Role,
	}
	_, err = r.UserUpdate(ctx, email, &usr)
	if err != nil {
		return "", fmt.Errorf("failed to update user: %w", err)
	}
	return fmt.Sprintf("user with email %s updated successfully", email), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	user, err := r.UserByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch user by id: %w", err)
	}
	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	usr := model.ConvertToGraphQLUser(*user)
	return usr, nil
}

// UserEmail is the resolver for the userEmail field.
func (r *queryResolver) UserEmail(ctx context.Context, email string) (*model.User, error) {
	// Fetch user by email
	user, err := r.UserByEmail(ctx, email)
	if err != nil {
		return nil, fmt.Errorf("could not find user with email %s: %v", email, err)
	}

	// Convert to GraphQL User model
	usr := model.ConvertToGraphQLUser(*user)
	return usr, nil
}

// UsersByRole is the resolver for the usersByRole field.
// UsersByRole is the resolver for the usersByRole field.
func (r *queryResolver) UsersByRole(ctx context.Context, role string) ([]*model.User, error) {
	// Fetch users by role
	users, err := r.UserByRole(ctx, role)
	if err != nil {
		return nil, fmt.Errorf("could not find users with role %s: %v", role, err)
	}

	// Convert the list of users to GraphQL User models
	var graphQLUsers []*model.User
	for _, u := range users {
		graphQLUsers = append(graphQLUsers, model.ConvertToGraphQLUser(*u))
	}

	return graphQLUsers, nil
}

// Protected is the resolver for the protected field.
func (r *queryResolver) Protected(ctx context.Context) (string, error) {
	claims := middleware.CtxValue(ctx)
	if claims == nil {
		return "", fmt.Errorf("user not authenticated")
	}
	return fmt.Sprintf("Protected route accessed by user %s", claims.Email), nil
}

// GetMe is the resolver for the getMe field.
func (r *queryResolver) GetMe(ctx context.Context) (*model.User, error) {
	claims := middleware.CtxValue(ctx)
	if claims == nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	user, err := r.UserByID(ctx, claims.ID)
	if err != nil {
		return nil, fmt.Errorf("could not find user: %v", err)
	}
	usr := model.ConvertToGraphQLUser(*user)
	return usr, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
